<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: IT | EverET.org]]></title>
  <link href="http://everet.org/category/it/atom.xml" rel="self"/>
  <link href="http://everet.org/"/>
  <updated>2013-01-15T00:20:06+08:00</updated>
  <id>http://everet.org/</id>
  <author>
    <name><![CDATA[Stupid ET]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[让Emacs显示Markdown中的图片]]></title>
    <link href="http://everet.org/2013/01/emacs-markdown-display-image.html"/>
    <updated>2013-01-14T23:36:00+08:00</updated>
    <id>http://everet.org/2013/01/emacs-markdown-display-image</id>
    <content type="html"><![CDATA[<p>用Octopress或者直接用Jekyll都会涉及到Markdown。我们在写Markdown的时候，会遇到插入截图或者本地图片的问题。如果我们自己手工写上图片的标记，会非常的麻烦，于是我在前文 <a href="http://everet.org/2012/12/screenshot-and-image-paste-in-emacs-when-writing-markdown.html">在Emacs中插入截图或者本地图片</a> 中讲述如何自动化插入图片，来解决插入的问题。</p>

<p>今天我们来看一下如何在Emacs中预览Markdown中的图片。</p>

<!-- more -->

<p>虽然我们已经解决了插入图片不便，但我们有时看到这一串一串的文本图片标记或许有些许蛋疼，于是预览一下图片，此时又是Emacs展示其强大的时候了。</p>

<p>Emacs中有<code>iimage-mode</code>可以方便地让我们显示图片，是Emacs自带的。当然如果想在buffer中插入图片我们甚至可以直接调用<code>insert-image</code> <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>往buffer中插入图片。我想Vim里面如果要显示图片一定相当相当蛋疼吧，哈哈。Emacs用户真幸福。</p>

<h2 id="section">实现</h2>
<p>好，又到了动手的时候了，让我们卷起袖子准备开工！</p>

<p>``` cl iimage settings https://github.com/cedricporter/vim-emacs-setting/blob/master/emacs/.emacs.d/plugins/configs/my-iimage-settings.el my-iimage-settings.el
;; 
(require ‘iimage)</p>

<p>(add-hook ‘info-mode-hook ‘iimage-mode)
(add-hook ‘markdown-mode-hook ‘(lambda()
				 (define-key markdown-mode-map
				   (kbd “<f12>") 'turn-on-iimage-mode)))</f12></p>

<p>(setq iimage-mode-image-search-path ‘(list “.” “..”))</p>

<p>;; for octopress
(add-to-list ‘iimage-mode-image-regex-alist ; match: {% img xxx %}
	     (cons (concat “{% img /?\(“
			   iimage-mode-image-filename-regex
			   “\) %}”) 1))
(add-to-list ‘iimage-mode-image-regex-alist ; match: <img src="/xxx" alt="xxx" />
	     (cons (concat “!\<a href="http://everet.org/\\(wp-content/&quot;
			   iimage-mode-image-filename-regex" title="\\))">.<em>?\](/\(“
			   iimage-mode-image-filename-regex
			   “\))”) 1))
;; 兼容以前在wordpress添加的图片
(add-to-list ‘iimage-mode-image-regex-alist ; match: <img src="http://everet.org/xxx" alt="xxx" />
	     (cons (concat “!\[.</em>?\</a> 1))
;; 			 <br />
```</p>

<p>我们首先设置一下图片搜索路径<code>iimage-mode-image-search-path</code>，可以根据实际需要进行设置。对于Octopress的目录结构，我将其设置为当前以及上一级目录<code>(list "." "..")</code>。</p>

<p>然后，我们来设置图片的正则表达式，iimage会将文本中满足的正则表达式提取出来替换成图片。对于插入到<code>iimage-mode-image-regex-alist</code>中的正则表达式，为一个点对<code>(REGEXP . NUM)</code>。为什么是这样呢？因为正则表达式中可能会有很多级的括号，通过<code>NUM</code>我们可以指定取哪一个group的内容为图片路径，像NUM为0的时候取得是整个表达式的值，这个有疑问的话可以问一下Google大神。</p>

<p>最后，我们设置在<code>markdown-mode</code>中<code>F12</code>为开关图片显示。</p>

<h2 id="section-1">效果</h2>

<p><img src="/imgs/snapshot7<em>20130115</em>000417_4317rhI.png"></p>

<h2 id="footnote">Footnote</h2>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p><a href="http://www.gnu.org/software/emacs/manual/html_node/elisp/Showing-Images.html">Showing Images</a><a href="#fnref:1" rel="reference">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[学习HTTP] Transfer-Encoding: chunked]]></title>
    <link href="http://everet.org/2013/01/learn-http-chunked.html"/>
    <updated>2013-01-11T15:43:00+08:00</updated>
    <id>http://everet.org/2013/01/learn-http-chunked</id>
    <content type="html"><![CDATA[<p>在HTTP/1.1中，如果需要保持连接的话，那么Content-Length是必须要提供的。否则就无法确定此次请求的结束位置。</p>

<p>但是，如果我们要在<em>动态生成的过程中</em>就想发送数据，是无法预先知道报文的长度的，所以也就不可能使用Content-Length来指明body长度。那为啥要边生成边发送呢？假设生成完整数据需要30秒，如果要生成完再发送的话，那么就浪费了这30秒的美好的传输时间了。chunked就解决了这个难题，只要服务器允许将body逐块发送，并说明每块的大小就可以了。</p>

<p><strong>那如何边生成边发送呢？</strong></p>

<p>我们可以通过将Transfer-Encoding指定为chunked，来进行分块传输。我们就可以将原本一整块需要说明长度的数据分解成了一小块一小块需要说明长度的数据。就可以边生成边发送了。</p>

<!-- more -->

<p>Chunked Transfer Coding在rfc2616 <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> 中的文法定义如下：</p>

<p><code>ini 
Chunked-Body   = *chunk
                 last-chunk
                 trailer
                 CRLF
chunk          = chunk-size [ chunk-extension ] CRLF
                 chunk-data CRLF
chunk-size     = 1*HEX
last-chunk     = 1*("0") [ chunk-extension ] CRLF
chunk-extension= *( ";" chunk-ext-name [ "=" chunk-ext-val ] )
chunk-ext-name = token
chunk-ext-val  = token | quoted-string
chunk-data     = chunk-size(OCTET)
trailer        = *(entity-header CRLF)
</code></p>

<p>对于每一个chunk，由chunk-size开头，这个是一个<strong>16进制</strong>数字的字符串，用来表示后面将有多长的数据。然后跟着的是数据。这里chunk-size和Content-Length的作用是相似的。最后结束的chunk的chunk-size为<code>0</code>。Chunk可以理解成类似这样的结构体，size指明data的长度:</p>

<p><code>c
struct Chunk
{
    int size;
    char *data;
};
</code></p>

<h2 id="section">测试</h2>

<p>我们用nc<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>作为服务器，看看浏览器的反应如何。通过nc，我们可以直接构造响应。</p>

<p>用nc监听本地8888端口，然后用浏览器访问本地8888端口，然后就可以看到浏览器发来的请求报文（2-11行）。然后我们模仿服务器发回响应（12-22行）。</p>

<p>``` console 使用nc扮演服务器 
$ nc -lp 8888
GET / HTTP/1.1
Host: localhost:8888
Connection: keep-alive
Cache-Control: max-age=0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,<em>/</em>;q=0.8
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.17 (KHTML, like Gecko) Chrome/24.0.1312.52 Safari/537.17
Accept-Encoding: gzip,deflate,sdch
Accept-Language: zh,zh-CN;q=0.8,en-US;q=0.6,en;q=0.4
Accept-Charset: UTF-8,*;q=0.5</p>

<p>HTTP/1.1 200 OK
Connection: close
Transfer-Encoding: chunked</p>

<p>A
This is Ev<br />
9
erET.org.
0</p>

<p>```</p>

<p>可以看到，Chunked-Body的内容分为一块一块的，最后以<code>0</code>结束。</p>

<p></p>

<p>最后，在浏览器可以看到的内容为<code>This is EverET.org.</code>。</p>

<p>(全文完）</p>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.6">Transfer Codings</a> , <a href="http://greenbytes.de/tech/webdav/draft-ietf-httpbis-p1-messaging-13.html#rfc.section.6.2.1">Chunked Transfer Coding</a><a href="#fnref:1" rel="reference">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>netcat，黑客工具中的瑞士军刀。<a href="#fnref:2" rel="reference">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[定制Emacs GDB调试窗口布局]]></title>
    <link href="http://everet.org/2013/01/customize-emacs-gud-many-windows.html"/>
    <updated>2013-01-09T01:06:00+08:00</updated>
    <id>http://everet.org/2013/01/customize-emacs-gud-many-windows</id>
    <content type="html"><![CDATA[<p>我们在Emacs中可以方便地使用GDB，具体操作在<a href="http://emacser.com/emacs-gdb.htm">emacser.com</a>有详细的快捷键的教程。不过我觉得其实GDB的CLI已经很好用了。</p>

<p>Emacs中默认可以方便打开多窗格模式，看起来就很像平时大家用的IDE了。</p>

<p>我们只需要<code>M-x gdb-many-windows</code>就可以打开多窗格了，默认布局如下图：</p>

<p><img src="/imgs/snapshot4<em>20130109</em>011149_15479HnD.png"></p>

<p>我们可以看到有6个窗格，其中有GDB命令行、局部变量、源代码、程序输出、栈、断点。功能看上去虽然很强大，不过我常用的只有其中几个，于是就决定开始定制Emacs的GDB调试窗口布局。</p>

<!-- more -->

<p>我常用的是代码框、输出、GDB命令行以及栈，什么断点、局部变量基本可以在需要的时候用<code>i b</code>，<code>i locals</code>查看就可以了，没必要弄这么小一个窗格占住位置，而且想看的时候还看不完整。</p>

<h2 id="section">定制</h2>

<p>于是开始按照我的心意，将其定制成如下这样。</p>

<p><img src="/imgs/snapshot5<em>20130109</em>011857_15479UxJ.png"></p>

<p>这样用起来比较爽，没有不需要的窗格。各位看官也可以根据自己的需要配置。</p>

<p><code>gdb-many-windows</code>的窗口布局是写死在<code>gdb-setup-windows</code>这个函数里面，我们最好的方法就是<code>defadvice</code>这个函数。代码如下：</p>

<p><code>cl
(defadvice gdb-setup-windows (after my-setup-gdb-windows activate)
  "my gdb UI"
  (gdb-get-buffer-create 'gdb-stack-buffer)
  (set-window-dedicated-p (selected-window) nil)
  (switch-to-buffer gud-comint-buffer)
  (delete-other-windows)
  (let ((win0 (selected-window))        
        (win1 (split-window nil nil 'left))      ;code and output
        (win2 (split-window-below (/ (* (window-height) 2) 3)))     ;stack
        )
    (select-window win2)
    (gdb-set-window-buffer (gdb-stack-buffer-name))
    (select-window win1)
    (set-window-buffer
     win1
     (if gud-last-last-frame
         (gud-find-file (car gud-last-last-frame))
       (if gdb-main-file
           (gud-find-file gdb-main-file)
         ;; Put buffer list in window if we
         ;; can't find a source file.
         (list-buffers-noselect))))
    (setq gdb-source-window (selected-window))
    (let ((win3 (split-window nil (/ (* (window-height) 3) 4)))) ;io
      (gdb-set-window-buffer (gdb-get-buffer-create 'gdb-inferior-io) nil win3))
    (select-window win0)
    ))
</code></p>

<p>经过<code>defadvice</code>就可以修改原来定义的函数了，从而我们就可以定制UI了。</p>

<blockquote>
  <p>Emacs是伪装成编辑器的操作系统～～～</p>
</blockquote>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[学习HTTP] 206 Partial Content]]></title>
    <link href="http://everet.org/2013/01/http-status-206-partial-content.html"/>
    <updated>2013-01-06T10:31:00+08:00</updated>
    <id>http://everet.org/2013/01/http-status-206-partial-content</id>
    <content type="html"><![CDATA[<p>俺在把博客放在Github后，除了发现Github的Web Server将Cache-Control设置为max-age=86400外，还发现一个有趣的地方。Chrome在对于MP3文件的访问，Github返回的都是<code>206 Partial Content</code>，后来发现，原来Chrome在请求MP3的时候，会在请求头带上<code>Range: bytes=0-</code>。</p>

<p>对于2xx的返回码，都是成功的，不过常见的基本都是200，206到时挺少见滴，于是俺决定看看206究竟有什么特别的地方。</p>

<p>rfc2616日：对于206的定义是请求<strong>必须</strong>包含<code>Range</code>头来标示我们想要的范围，于是这也就说明Chrome访问MP3的时候因为加了<code>Range</code>头，于是被返回了206。</p>

<p>我们来看一下下面的例子：用curl请求<a href="http://everet.org/2013/01/chrome-edit-with-emacs.html">http://everet.org/2013/01/chrome-edit-with-emacs.html</a>，返回<code>200 OK</code>，其中<code>Content-Length: 15845</code>。</p>

<p><code>bash
$ curl --head http://everet.org/2013/01/chrome-edit-with-emacs.html
HTTP/1.1 200 OK
Server: GitHub.com
Date: Sun, 06 Jan 2013 02:47:09 GMT
Content-Type: text/html
Content-Length: 15845
Last-Modified: Sat, 05 Jan 2013 10:30:34 GMT
Connection: keep-alive
Expires: Mon, 07 Jan 2013 02:47:09 GMT
Cache-Control: max-age=86400
Accept-Ranges: bytes
</code></p>

<p>那根据rfc2616的说法，是不是加上<code>Range</code>后，Web Server就会返回<code>206 Partial Content</code>了呢？我们来通过telnet试一试：</p>

<!-- more -->

<p>``` bash
$ telnet everet.org www
Trying 204.232.175.78…
Connected to everet.org.
Escape character is ‘^]’.
GET /2013/01/chrome-edit-with-emacs.html HTTP/1.1
Host: everet.org
Range: bytes=0-100</p>

<p>HTTP/1.1 206 Partial Content
Server: GitHub.com
Date: Sun, 06 Jan 2013 03:20:05 GMT
Content-Type: text/html
Content-Length: 101
Last-Modified: Sat, 05 Jan 2013 10:30:34 GMT
Connection: keep-alive
Expires: Mon, 07 Jan 2013 03:20:05 GMT
Cache-Control: max-age=86400
Content-Range: bytes 0-100/15845</p>

<p>&lt;!DOCTYPE html&gt;
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
&lt;!–[if lt IE 9]&gt;&lt;html cl
```</p>

<p>可以看到，服务器返回了100个字节的字符。为了方便测试，我们使用curl来尝试分块下载。</p>

<p><code>bash
$ curl http://everet.org/2013/01/chrome-edit-with-emacs.html -o a.html
$ curl --header "Range: bytes=0-10000" http://everet.org/2013/01/chrome-edit-with-emacs.html -o p1
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
  100 10001  100 10001    0     0  13227      0 --:--:-- --:--:-- --:--:-- 20451
$ curl --header "Range: bytes=10001-" http://everet.org/2013/01/chrome-edit-with-emacs.html -o p2
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
  100  5844  100  5844    0     0   7778      0 --:--:-- --:--:-- --:--:-- 12175
$ cat p1 p2 &gt; b.html
$ diff a.html b.html 
</code></p>

<p>我们将原始页面下载回命名为a.html。然后通过增加<code>Range</code>这个header来下载<code>0-10000</code>为p1，以及<code>10001-</code>下载剩余部分为p2。然后合并p1、p2为b.html。通过<code>diff a.html b.html</code>发现a.html和b.html内容完全一样。</p>

<p>嗯，正如我们所想的那样，加上<code>Range</code>后可以下载指定部分的内容，相应地服务器会返回<code>206 Partial Content</code>。</p>

<h2 id="range">Range范围的例子</h2>
<p>这个例子是rfc2616里面的，首先假定entity-body长度为10000。</p>

<ul>
  <li>获取前500个字节 (byte offsets 0-499, inclusive):  bytes=0-499</li>
  <li>获取第二个500字节 (byte offsets 500-999, inclusive): bytes=500-999</li>
  <li>获取最后500字节 (byte offsets 9500-9999, inclusive): bytes=-500</li>
  <li>获取最后500字节 bytes=9500-</li>
  <li>第一个和最后一个字节 (bytes 0 and 9999):  bytes=0-0,-1</li>
  <li>Several legal but not canonical specifications of the second 500
bytes (byte offsets 500-999, inclusive):
 bytes=500-600,601-999
 bytes=500-700,601-999</li>
</ul>

<h2 id="section">总结</h2>
<p>我们可以通过<code>Range</code>和<code>206 Partial Content</code>来分块获取一个大文件。在offset有效的时候，Web Server会返回206，否则会返回<code>416 Requested Range Not Satisfiable</code>。</p>

<h2 id="section-1">扩展阅读</h2>
<ul>
  <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html">Status Code Definitions</a></li>
  <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35">Range</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Chrome Edit With Emacs]]></title>
    <link href="http://everet.org/2013/01/chrome-edit-with-emacs.html"/>
    <updated>2013-01-05T16:46:00+08:00</updated>
    <id>http://everet.org/2013/01/chrome-edit-with-emacs</id>
    <content type="html"><![CDATA[<p>大家在浏览器写长篇的东西时，有没觉得那个纯文本编辑框弱爆了？反正我是这么觉得。像Github、<a href="http://stackoverflow.com/editing-help">stackoverflow</a>、Wiki等都支持Markdown，对于这种有语法的文本，最好就是用个语法高亮自动排版的编辑器编辑。</p>

<p>在Firefox有<a href="https://addons.mozilla.org/zh-cn/firefox/addon/its-all-text/">It’s All Text!</a>这个插件，可以调用外部编辑器。</p>

<p>而在Chrome里面，也有插件，可以调用外部的Emacs进行编辑，而且可以根据规则自动选择模式，非常方便。它的名字叫<a href="http://www.emacswiki.org/emacs/Edit_with_Emacs">Edit With Emacs</a>。</p>

<p>安装完插件后，Chrome所有的大Textarea都会出现一个蓝色的edit按钮，一按，就可以用Emacs编辑里面的内容了。</p>

<p><img src="/imgs/2013-01-05-chrome-edit-with-emacs.markdown<em>20130105</em>170235_21731e8F.png"></p>

<!-- more -->

<p>我们可以通过修改<code>edit-server-url-major-mode-alist</code>这个Association List<sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup>来添加网址规则，如下：</p>

<p>``` cl
(when (and (require ‘edit-server nil t) (daemonp))
;  (setq edit-server-new-frame nil)
  (edit-server-start))</p>

<p>(setq edit-server-url-major-mode-alist
      ‘((“github\.com” . markdown-mode)
	(“i\.everet\.org” . moinmoin-mode)))
```</p>

<p>Edit With Emacs的工作原理是在Emacs里面开一个服务器，监听9292端口，然后Chrome插件将文本POST到Emacs里面编辑，编辑完再返回回去。</p>

<p>不过它的Emacs端在编辑中文url的textarea会有bug（因为中文在url中被转义成了%xx%xx这种形式，这个%在format的时候没转义好，于是format的时候就SB了），提交了issue不过作者暂时没理，我们自己注释掉<code>edit-server-find-or-create-edit-buffer</code>下面的<code>edit-server-log</code>就行了（diff：<a href="https://github.com/cedricporter/vim-emacs-setting/commit/a3069e50fd3bce90ca46be6ba784e47cd9d198ca#emacs/.emacs.d/plugins/edit-server.el">edit-server.el</a>）。</p>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p><a href="http://www.gnu.org/software/emacs/manual/html_node/elisp/Association-Lists.html">Association Lists</a><a href="#fnref:1" rel="reference">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
</feed>
