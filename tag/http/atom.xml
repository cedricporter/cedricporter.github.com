<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: HTTP | EverET.org]]></title>
  <link href="http://everet.org/tag/http/atom.xml" rel="self"/>
  <link href="http://everet.org/"/>
  <updated>2013-01-06T13:03:44+08:00</updated>
  <id>http://everet.org/</id>
  <author>
    <name><![CDATA[Stupid ET]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[学习HTTP] 206 Partial Content]]></title>
    <link href="http://everet.org/2013/01/http-status-206-partial-content.html"/>
    <updated>2013-01-06T10:31:00+08:00</updated>
    <id>http://everet.org/2013/01/http-status-206-partial-content</id>
    <content type="html"><![CDATA[<p>俺在把博客放在Github后，除了发现Github的Web Server将Cache-Control设置为max-age=86400外，还发现一个有趣的地方。Chrome在对于MP3文件的访问，Github返回的都是<code>206 Partial Content</code>，后来发现，原来Chrome在请求MP3的时候，会在请求头带上<code>Range: bytes=0-</code>。</p>

<p>对于2xx的返回码，都是成功的，不过常见的基本都是200，206到时挺少见滴，于是俺决定看看206究竟有什么特别的地方。</p>

<p>rfc2616日：对于206的定义是请求<strong>必须</strong>包含<code>Range</code>头来标示我们想要的范围，于是这也就说明Chrome访问MP3的时候因为加了<code>Range</code>头，于是被返回了206。</p>

<p>我们来看一下下面的例子：用curl请求<a href="http://everet.org/2013/01/chrome-edit-with-emacs.html">http://everet.org/2013/01/chrome-edit-with-emacs.html</a>，返回<code>200 OK</code>，其中<code>Content-Length: 15845</code>。</p>

<p><code>bash
$ curl --head http://everet.org/2013/01/chrome-edit-with-emacs.html
HTTP/1.1 200 OK
Server: GitHub.com
Date: Sun, 06 Jan 2013 02:47:09 GMT
Content-Type: text/html
Content-Length: 15845
Last-Modified: Sat, 05 Jan 2013 10:30:34 GMT
Connection: keep-alive
Expires: Mon, 07 Jan 2013 02:47:09 GMT
Cache-Control: max-age=86400
Accept-Ranges: bytes
</code></p>

<p>那根据rfc2616的说法，是不是加上<code>Range</code>后，Web Server就会返回<code>206 Partial Content</code>了呢？我们来通过telnet试一试：</p>

<!-- more -->

<p>``` bash
$ telnet everet.org www
Trying 204.232.175.78…
Connected to everet.org.
Escape character is ‘^]’.
GET /2013/01/chrome-edit-with-emacs.html HTTP/1.1
Host: everet.org
Range: bytes=0-100</p>

<p>HTTP/1.1 206 Partial Content
Server: GitHub.com
Date: Sun, 06 Jan 2013 03:20:05 GMT
Content-Type: text/html
Content-Length: 101
Last-Modified: Sat, 05 Jan 2013 10:30:34 GMT
Connection: keep-alive
Expires: Mon, 07 Jan 2013 03:20:05 GMT
Cache-Control: max-age=86400
Content-Range: bytes 0-100/15845</p>

<p>&lt;!DOCTYPE html&gt;
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
&lt;!–[if lt IE 9]&gt;&lt;html cl
```</p>

<p>可以看到，服务器返回了100个字节的字符。为了方便测试，我们使用curl来尝试分块下载。</p>

<p><code>bash
$ curl http://everet.org/2013/01/chrome-edit-with-emacs.html -o a.html
$ curl --header "Range: bytes=0-10000" http://everet.org/2013/01/chrome-edit-with-emacs.html -o p1
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
  100 10001  100 10001    0     0  13227      0 --:--:-- --:--:-- --:--:-- 20451
$ curl --header "Range: bytes=10001-" http://everet.org/2013/01/chrome-edit-with-emacs.html -o p2
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
  100  5844  100  5844    0     0   7778      0 --:--:-- --:--:-- --:--:-- 12175
$ cat p1 p2 &gt; b.html
$ diff a.html b.html 
</code></p>

<p>我们将原始页面下载回命名为a.html。然后通过增加<code>Range</code>这个header来下载<code>0-10000</code>为p1，以及<code>10001-</code>下载剩余部分为p2。然后合并p1、p2为b.html。通过<code>diff a.html b.html</code>发现a.html和b.html内容完全一样。</p>

<p>嗯，正如我们所想的那样，加上<code>Range</code>后可以下载指定部分的内容，相应地服务器会返回<code>206 Partial Content</code>。</p>

<h2 id="range">Range范围的例子</h2>
<p>这个例子是rfc2616里面的，首先假定entity-body长度为10000。</p>

<ul>
  <li>获取前500个字节 (byte offsets 0-499, inclusive):  bytes=0-499</li>
  <li>获取第二个500字节 (byte offsets 500-999, inclusive): bytes=500-999</li>
  <li>获取最后500字节 (byte offsets 9500-9999, inclusive): bytes=-500</li>
  <li>获取最后500字节 bytes=9500-</li>
  <li>第一个和最后一个字节 (bytes 0 and 9999):  bytes=0-0,-1</li>
  <li>Several legal but not canonical specifications of the second 500
bytes (byte offsets 500-999, inclusive):
 bytes=500-600,601-999
 bytes=500-700,601-999</li>
</ul>

<h2 id="section">总结</h2>
<p>我们可以通过<code>Range</code>和<code>206 Partial Content</code>来分块获取一个大文件。在offset有效的时候，Web Server会返回206，否则会返回<code>416 Requested Range Not Satisfiable</code>。</p>

<h2 id="section-1">扩展阅读</h2>
<ul>
  <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html">Status Code Definitions</a></li>
  <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35">Range</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTTP状态码]]></title>
    <link href="http://everet.org/2012/02/the-http-status-code.html"/>
    <updated>2012-02-19T00:44:30+08:00</updated>
    <id>http://everet.org/2012/02/the-http-status-code</id>
    <content type="html"><![CDATA[<p>发现到了现在，我还是除了一些基本的状态码之外， 其他状态码都不是很熟悉，于是找了些状态码过来记录一下，也当做备忘了。</p>

<p>下面的拿Vim把返回码处理成表格还加了颜色，哈哈，果然用Vim就是像刷屏一样。配合宏真是无敌了！</p>

<p><strong>100</strong>
Continue</p>

<p>初始的请求已经接受，客户应当继续发送请求的其余部分</p>

<p><strong>101</strong>
Switching Protocols</p>

<p>服务器将遵从客户的请求转换到另外一种协议</p>

<p><strong>200</strong>
OK</p>

<p>一切正常，对GET和POST请求的应答文档跟在后面</p>

<p><strong>201</strong>
Created</p>

<p>服务器已经创建了文档，Location头给出了它的URL。</p>

<p><strong>202</strong>
Accepted</p>

<p>已经接受请求，但处理尚未完成。</p>

<!-- more -->

<p><strong>203</strong>
Non-Authoritative Information</p>

<p>文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝</p>

<p><strong>204</strong>
No Content</p>

<p>没有新文档，浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的</p>

<p><strong>205</strong>
Reset Content</p>

<p>没有新的内容，但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容</p>

<p><strong>206</strong>
Partial Content</p>

<p>客户发送了一个带有Range头的GET请求，服务器完成了它</p>

<p><strong>300</strong>
Multiple Choices</p>

<p>客户请求的文档可以在多个位置找到，这些位置已经在返回的文档内列出。如果服务器要提出优先选择，则应该在Location应答头指明。</p>

<p><strong>301</strong>
Moved Permanently</p>

<p>客户请求的文档在其他地方，新的URL在Location头中给出，浏览器应该自动地访问新的URL。</p>

<p><strong>302</strong>
Found</p>

<p>类似于301，但新的URL应该被视为临时性的替代，而不是永久性的。</p>

<p><strong>303</strong>
See Other</p>

<p>类似于301/302，不同之处在于，如果原来的请求是POST，Location头指定的重定向目标文档应该通过GET提取</p>

<p><strong>304</strong>
Not Modified</p>

<p>客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。<a href="http://xfeng.me/tags/%e6%9c%8d%e5%8a%a1%e5%99%a8/">服务器</a>告诉客户，原来缓冲的文档还可以继续使用。</p>

<p><strong>305</strong>
Use Proxy</p>

<p>客户请求的文档应该通过Location头所指明的代理服务器提取</p>

<p><strong>307</strong>
Temporary Redirect</p>

<p>和302（Found）相同。许多浏览器会错误地响应302应答进行重定向，即使原来的请求是 POST，即使它实际上只能在POST请求的应答是303时才能重定向。由于这个原因，HTTP 1.1新增了307，以便更加清除地区分几个状态代码： 当出现303应答时，浏览器可以跟随重定向的GET和POST请求；如果是307应答，则浏览器只能跟随对GET请求的重定向。</p>

<p><strong>400</strong>
Bad Request</p>

<p>请求出现语法错误。</p>

<p><strong>401</strong>
Unauthorized</p>

<p>客户试图未经授权访问受密码保护的页面。应答中会包含一个WWW-Authenticate头，浏览器据此显示用户名字/密码对话框，然后在填写合适的Authorization头后再次发出请求。</p>

<p><strong>403</strong>
Forbidden</p>

<p>资源不可用。</p>

<p><strong>404</strong>
Not Found</p>

<p>无法找到指定位置的资源</p>

<p><strong>405</strong>
Method Not Allowed</p>

<p>请求方法（GET、POST、HEAD、Delete、PUT、TRACE等）对指定的资源不适用。</p>

<p><strong>406</strong>
Not Acceptable</p>

<p>指定的资源已经找到，但它的MIME类型和客户在Accpet头中所指定的不兼容</p>

<p><strong>407</strong>
Proxy Authentication Required</p>

<p>类似于401，表示客户必须先经过代理服务器的授权。</p>

<p><strong>408</strong>
Request Timeout</p>

<p>在服务器许可的等待时间内，客户一直没有发出任何请求。客户可以在以后重复同一请求。</p>

<p><strong>409</strong>
Conflict</p>

<p>通常和PUT请求有关。由于请求和资源的当前状态相冲突，因此请求不能成功。</p>

<p><strong>410</strong>
Gone</p>

<p>所请求的文档已经不再可用，而且服务器不知道应该重定向到哪一个地址。它和404的不同在于，返回407表示文档永久地离开了指定的位置，而404表示由于未知的原因文档不可用。</p>

<p><strong>411</strong>
Length Required</p>

<p>服务器不能处理请求，除非客户发送一个Content-Length头。</p>

<p><strong>412</strong>
Precondition Failed</p>

<p>请求头中指定的一些前提条件失败</p>

<p><strong>413</strong>
Request Entity Too Large</p>

<p>目标文档的大小超过服务器当前愿意处理的大小。如果服务器认为自己能够稍后再处理该请求，则应该提供一个Retry-After头</p>

<p><strong>414</strong>
Request URI Too Long</p>

<p>URI太长</p>

<p><strong>416</strong>
Requested Range Not Satisfiable</p>

<p>服务器不能满足客户在请求中指定的Range头</p>

<p><strong>500</strong>
Internal Server Error</p>

<p>服务器遇到了意料不到的情况，不能完成客户的请求</p>

<p><strong>501</strong>
Not Implemented</p>

<p>服务器不支持实现请求所需要的功能。例如，客户发出了一个服务器不支持的PUT请求</p>

<p><strong>502</strong>
Bad Gateway</p>

<p>服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答</p>

<p><strong>503</strong>
Service Unavailable</p>

<p>服务器由于维护或者负载过重未能应答。例如，Servlet可能在数据库连接池已满的情况下返回503。服务器返回503时可以提供一个Retry-After头</p>

<p><strong>504</strong>
Gateway Timeout</p>

<p>由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答</p>

<p><strong>505</strong>
HTTP Version Not Supported</p>

<p>服务器不支持请求中所指明的HTTP版本</p>

]]></content>
  </entry>
  
</feed>
