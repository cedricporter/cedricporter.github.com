<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: HTTP | EverET.org]]></title>
  <link href="http://everet.org/tag/http/atom.xml" rel="self"/>
  <link href="http://everet.org/"/>
  <updated>2013-01-13T01:49:43+08:00</updated>
  <id>http://everet.org/</id>
  <author>
    <name><![CDATA[Stupid ET]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[学习HTTP] Transfer-Encoding: chunked]]></title>
    <link href="http://everet.org/2013/01/learn-http-chunked.html"/>
    <updated>2013-01-11T15:43:00+08:00</updated>
    <id>http://everet.org/2013/01/learn-http-chunked</id>
    <content type="html"><![CDATA[<p>在HTTP/1.1中，如果需要保持连接的话，那么Content-Length是必须要提供的。否则就无法确定此次请求的结束位置。</p>

<p>但是，如果我们要在<em>动态生成的过程中</em>就想发送数据，是无法预先知道报文的长度的，所以也就不可能使用Content-Length来指明body长度。那为啥要边生成边发送呢？假设生成完整数据需要30秒，如果要生成完再发送的话，那么就浪费了这30秒的美好的传输时间了。chunked就解决了这个难题，只要服务器允许将body逐块发送，并说明每块的大小就可以了。</p>

<p><strong>那如何边生成边发送呢？</strong></p>

<p>我们可以通过将Transfer-Encoding指定为chunked，来进行分块传输。我们就可以将原本一整块需要说明长度的数据分解成了一小块一小块需要说明长度的数据。就可以边生成边发送了。</p>

<!-- more -->

<p>Chunked Transfer Coding在rfc2616 <sup id="fnref:1"><a href="#fn:1" rel="footnote">1</a></sup> 中的文法定义如下：</p>

<p><code>ini 
Chunked-Body   = *chunk
                 last-chunk
                 trailer
                 CRLF
chunk          = chunk-size [ chunk-extension ] CRLF
                 chunk-data CRLF
chunk-size     = 1*HEX
last-chunk     = 1*("0") [ chunk-extension ] CRLF
chunk-extension= *( ";" chunk-ext-name [ "=" chunk-ext-val ] )
chunk-ext-name = token
chunk-ext-val  = token | quoted-string
chunk-data     = chunk-size(OCTET)
trailer        = *(entity-header CRLF)
</code></p>

<p>对于每一个chunk，由chunk-size开头，这个是一个<strong>16进制</strong>数字的字符串，用来表示后面将有多长的数据。然后跟着的是数据。这里chunk-size和Content-Length的作用是相似的。最后结束的chunk的chunk-size为<code>0</code>。Chunk可以理解成类似这样的结构体，size指明data的长度:</p>

<p><code>c
struct Chunk
{
    int size;
    char *data;
};
</code></p>

<h2 id="section">测试</h2>

<p>我们用nc<sup id="fnref:2"><a href="#fn:2" rel="footnote">2</a></sup>作为服务器，看看浏览器的反应如何。通过nc，我们可以直接构造响应。</p>

<p>用nc监听本地8888端口，然后用浏览器访问本地8888端口，然后就可以看到浏览器发来的请求报文（2-11行）。然后我们模仿服务器发回响应（12-22行）。</p>

<p>``` console 使用nc扮演服务器 
$ nc -lp 8888
GET / HTTP/1.1
Host: localhost:8888
Connection: keep-alive
Cache-Control: max-age=0
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,<em>/</em>;q=0.8
User-Agent: Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.17 (KHTML, like Gecko) Chrome/24.0.1312.52 Safari/537.17
Accept-Encoding: gzip,deflate,sdch
Accept-Language: zh,zh-CN;q=0.8,en-US;q=0.6,en;q=0.4
Accept-Charset: UTF-8,*;q=0.5</p>

<p>HTTP/1.1 200 OK
Connection: close
Transfer-Encoding: chunked</p>

<p>A
This is Ev<br />
9
erET.org.
0</p>

<p>```</p>

<p>可以看到，Chunked-Body的内容分为一块一块的，最后以<code>0</code>结束。</p>

<p></p>

<p>最后，在浏览器可以看到的内容为<code>This is EverET.org.</code>。</p>

<p>(全文完）</p>

<div class="footnotes">
  <ol>
    <li id="fn:1">
      <p><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html#sec3.6">Transfer Codings</a> , <a href="http://greenbytes.de/tech/webdav/draft-ietf-httpbis-p1-messaging-13.html#rfc.section.6.2.1">Chunked Transfer Coding</a><a href="#fnref:1" rel="reference">&#8617;</a></p>
    </li>
    <li id="fn:2">
      <p>netcat，黑客工具中的瑞士军刀。<a href="#fnref:2" rel="reference">&#8617;</a></p>
    </li>
  </ol>
</div>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[[学习HTTP] 206 Partial Content]]></title>
    <link href="http://everet.org/2013/01/http-status-206-partial-content.html"/>
    <updated>2013-01-06T10:31:00+08:00</updated>
    <id>http://everet.org/2013/01/http-status-206-partial-content</id>
    <content type="html"><![CDATA[<p>俺在把博客放在Github后，除了发现Github的Web Server将Cache-Control设置为max-age=86400外，还发现一个有趣的地方。Chrome在对于MP3文件的访问，Github返回的都是<code>206 Partial Content</code>，后来发现，原来Chrome在请求MP3的时候，会在请求头带上<code>Range: bytes=0-</code>。</p>

<p>对于2xx的返回码，都是成功的，不过常见的基本都是200，206到时挺少见滴，于是俺决定看看206究竟有什么特别的地方。</p>

<p>rfc2616日：对于206的定义是请求<strong>必须</strong>包含<code>Range</code>头来标示我们想要的范围，于是这也就说明Chrome访问MP3的时候因为加了<code>Range</code>头，于是被返回了206。</p>

<p>我们来看一下下面的例子：用curl请求<a href="http://everet.org/2013/01/chrome-edit-with-emacs.html">http://everet.org/2013/01/chrome-edit-with-emacs.html</a>，返回<code>200 OK</code>，其中<code>Content-Length: 15845</code>。</p>

<p><code>bash
$ curl --head http://everet.org/2013/01/chrome-edit-with-emacs.html
HTTP/1.1 200 OK
Server: GitHub.com
Date: Sun, 06 Jan 2013 02:47:09 GMT
Content-Type: text/html
Content-Length: 15845
Last-Modified: Sat, 05 Jan 2013 10:30:34 GMT
Connection: keep-alive
Expires: Mon, 07 Jan 2013 02:47:09 GMT
Cache-Control: max-age=86400
Accept-Ranges: bytes
</code></p>

<p>那根据rfc2616的说法，是不是加上<code>Range</code>后，Web Server就会返回<code>206 Partial Content</code>了呢？我们来通过telnet试一试：</p>

<!-- more -->

<p>``` bash
$ telnet everet.org www
Trying 204.232.175.78…
Connected to everet.org.
Escape character is ‘^]’.
GET /2013/01/chrome-edit-with-emacs.html HTTP/1.1
Host: everet.org
Range: bytes=0-100</p>

<p>HTTP/1.1 206 Partial Content
Server: GitHub.com
Date: Sun, 06 Jan 2013 03:20:05 GMT
Content-Type: text/html
Content-Length: 101
Last-Modified: Sat, 05 Jan 2013 10:30:34 GMT
Connection: keep-alive
Expires: Mon, 07 Jan 2013 03:20:05 GMT
Cache-Control: max-age=86400
Content-Range: bytes 0-100/15845</p>

<p>&lt;!DOCTYPE html&gt;
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
&lt;!–[if lt IE 9]&gt;&lt;html cl
```</p>

<p>可以看到，服务器返回了100个字节的字符。为了方便测试，我们使用curl来尝试分块下载。</p>

<p><code>bash
$ curl http://everet.org/2013/01/chrome-edit-with-emacs.html -o a.html
$ curl --header "Range: bytes=0-10000" http://everet.org/2013/01/chrome-edit-with-emacs.html -o p1
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
  100 10001  100 10001    0     0  13227      0 --:--:-- --:--:-- --:--:-- 20451
$ curl --header "Range: bytes=10001-" http://everet.org/2013/01/chrome-edit-with-emacs.html -o p2
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
  100  5844  100  5844    0     0   7778      0 --:--:-- --:--:-- --:--:-- 12175
$ cat p1 p2 &gt; b.html
$ diff a.html b.html 
</code></p>

<p>我们将原始页面下载回命名为a.html。然后通过增加<code>Range</code>这个header来下载<code>0-10000</code>为p1，以及<code>10001-</code>下载剩余部分为p2。然后合并p1、p2为b.html。通过<code>diff a.html b.html</code>发现a.html和b.html内容完全一样。</p>

<p>嗯，正如我们所想的那样，加上<code>Range</code>后可以下载指定部分的内容，相应地服务器会返回<code>206 Partial Content</code>。</p>

<h2 id="range">Range范围的例子</h2>
<p>这个例子是rfc2616里面的，首先假定entity-body长度为10000。</p>

<ul>
  <li>获取前500个字节 (byte offsets 0-499, inclusive):  bytes=0-499</li>
  <li>获取第二个500字节 (byte offsets 500-999, inclusive): bytes=500-999</li>
  <li>获取最后500字节 (byte offsets 9500-9999, inclusive): bytes=-500</li>
  <li>获取最后500字节 bytes=9500-</li>
  <li>第一个和最后一个字节 (bytes 0 and 9999):  bytes=0-0,-1</li>
  <li>Several legal but not canonical specifications of the second 500
bytes (byte offsets 500-999, inclusive):
 bytes=500-600,601-999
 bytes=500-700,601-999</li>
</ul>

<h2 id="section">总结</h2>
<p>我们可以通过<code>Range</code>和<code>206 Partial Content</code>来分块获取一个大文件。在offset有效的时候，Web Server会返回206，否则会返回<code>416 Requested Range Not Satisfiable</code>。</p>

<h2 id="section-1">扩展阅读</h2>
<ul>
  <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html">Status Code Definitions</a></li>
  <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35">Range</a></li>
</ul>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[HTTP状态码]]></title>
    <link href="http://everet.org/2012/02/the-http-status-code.html"/>
    <updated>2012-02-19T00:44:30+08:00</updated>
    <id>http://everet.org/2012/02/the-http-status-code</id>
    <content type="html"><![CDATA[<p>发现到了现在，我还是除了一些基本的状态码之外， 其他状态码都不是很熟悉，于是找了些状态码过来记录一下，也当做备忘了。</p>

<p>下面的拿Vim把返回码处理成表格还加了颜色，哈哈，果然用Vim就是像刷屏一样。配合宏真是无敌了！</p>

<p><strong>100</strong>
Continue</p>

<p>初始的请求已经接受，客户应当继续发送请求的其余部分</p>

<p><strong>101</strong>
Switching Protocols</p>

<p>服务器将遵从客户的请求转换到另外一种协议</p>

<p><strong>200</strong>
OK</p>

<p>一切正常，对GET和POST请求的应答文档跟在后面</p>

<p><strong>201</strong>
Created</p>

<p>服务器已经创建了文档，Location头给出了它的URL。</p>

<p><strong>202</strong>
Accepted</p>

<p>已经接受请求，但处理尚未完成。</p>

<!-- more -->

<p><strong>203</strong>
Non-Authoritative Information</p>

<p>文档已经正常地返回，但一些应答头可能不正确，因为使用的是文档的拷贝</p>

<p><strong>204</strong>
No Content</p>

<p>没有新文档，浏览器应该继续显示原来的文档。如果用户定期地刷新页面，而Servlet可以确定用户文档足够新，这个状态代码是很有用的</p>

<p><strong>205</strong>
Reset Content</p>

<p>没有新的内容，但浏览器应该重置它所显示的内容。用来强制浏览器清除表单输入内容</p>

<p><strong>206</strong>
Partial Content</p>

<p>客户发送了一个带有Range头的GET请求，服务器完成了它</p>

<p><strong>300</strong>
Multiple Choices</p>

<p>客户请求的文档可以在多个位置找到，这些位置已经在返回的文档内列出。如果服务器要提出优先选择，则应该在Location应答头指明。</p>

<p><strong>301</strong>
Moved Permanently</p>

<p>客户请求的文档在其他地方，新的URL在Location头中给出，浏览器应该自动地访问新的URL。</p>

<p><strong>302</strong>
Found</p>

<p>类似于301，但新的URL应该被视为临时性的替代，而不是永久性的。</p>

<p><strong>303</strong>
See Other</p>

<p>类似于301/302，不同之处在于，如果原来的请求是POST，Location头指定的重定向目标文档应该通过GET提取</p>

<p><strong>304</strong>
Not Modified</p>

<p>客户端有缓冲的文档并发出了一个条件性的请求（一般是提供If-Modified-Since头表示客户只想比指定日期更新的文档）。<a href="http://xfeng.me/tags/%e6%9c%8d%e5%8a%a1%e5%99%a8/">服务器</a>告诉客户，原来缓冲的文档还可以继续使用。</p>

<p><strong>305</strong>
Use Proxy</p>

<p>客户请求的文档应该通过Location头所指明的代理服务器提取</p>

<p><strong>307</strong>
Temporary Redirect</p>

<p>和302（Found）相同。许多浏览器会错误地响应302应答进行重定向，即使原来的请求是 POST，即使它实际上只能在POST请求的应答是303时才能重定向。由于这个原因，HTTP 1.1新增了307，以便更加清除地区分几个状态代码： 当出现303应答时，浏览器可以跟随重定向的GET和POST请求；如果是307应答，则浏览器只能跟随对GET请求的重定向。</p>

<p><strong>400</strong>
Bad Request</p>

<p>请求出现语法错误。</p>

<p><strong>401</strong>
Unauthorized</p>

<p>客户试图未经授权访问受密码保护的页面。应答中会包含一个WWW-Authenticate头，浏览器据此显示用户名字/密码对话框，然后在填写合适的Authorization头后再次发出请求。</p>

<p><strong>403</strong>
Forbidden</p>

<p>资源不可用。</p>

<p><strong>404</strong>
Not Found</p>

<p>无法找到指定位置的资源</p>

<p><strong>405</strong>
Method Not Allowed</p>

<p>请求方法（GET、POST、HEAD、Delete、PUT、TRACE等）对指定的资源不适用。</p>

<p><strong>406</strong>
Not Acceptable</p>

<p>指定的资源已经找到，但它的MIME类型和客户在Accpet头中所指定的不兼容</p>

<p><strong>407</strong>
Proxy Authentication Required</p>

<p>类似于401，表示客户必须先经过代理服务器的授权。</p>

<p><strong>408</strong>
Request Timeout</p>

<p>在服务器许可的等待时间内，客户一直没有发出任何请求。客户可以在以后重复同一请求。</p>

<p><strong>409</strong>
Conflict</p>

<p>通常和PUT请求有关。由于请求和资源的当前状态相冲突，因此请求不能成功。</p>

<p><strong>410</strong>
Gone</p>

<p>所请求的文档已经不再可用，而且服务器不知道应该重定向到哪一个地址。它和404的不同在于，返回407表示文档永久地离开了指定的位置，而404表示由于未知的原因文档不可用。</p>

<p><strong>411</strong>
Length Required</p>

<p>服务器不能处理请求，除非客户发送一个Content-Length头。</p>

<p><strong>412</strong>
Precondition Failed</p>

<p>请求头中指定的一些前提条件失败</p>

<p><strong>413</strong>
Request Entity Too Large</p>

<p>目标文档的大小超过服务器当前愿意处理的大小。如果服务器认为自己能够稍后再处理该请求，则应该提供一个Retry-After头</p>

<p><strong>414</strong>
Request URI Too Long</p>

<p>URI太长</p>

<p><strong>416</strong>
Requested Range Not Satisfiable</p>

<p>服务器不能满足客户在请求中指定的Range头</p>

<p><strong>500</strong>
Internal Server Error</p>

<p>服务器遇到了意料不到的情况，不能完成客户的请求</p>

<p><strong>501</strong>
Not Implemented</p>

<p>服务器不支持实现请求所需要的功能。例如，客户发出了一个服务器不支持的PUT请求</p>

<p><strong>502</strong>
Bad Gateway</p>

<p>服务器作为网关或者代理时，为了完成请求访问下一个服务器，但该服务器返回了非法的应答</p>

<p><strong>503</strong>
Service Unavailable</p>

<p>服务器由于维护或者负载过重未能应答。例如，Servlet可能在数据库连接池已满的情况下返回503。服务器返回503时可以提供一个Retry-After头</p>

<p><strong>504</strong>
Gateway Timeout</p>

<p>由作为代理或网关的服务器使用，表示不能及时地从远程服务器获得应答</p>

<p><strong>505</strong>
HTTP Version Not Supported</p>

<p>服务器不支持请求中所指明的HTTP版本</p>

]]></content>
  </entry>
  
</feed>
