<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Tag: curl | EverET.org]]></title>
  <link href="http://everet.org/tag/curl/atom.xml" rel="self"/>
  <link href="http://everet.org/"/>
  <updated>2013-01-09T10:23:40+08:00</updated>
  <id>http://everet.org/</id>
  <author>
    <name><![CDATA[Stupid ET]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[[学习HTTP] 206 Partial Content]]></title>
    <link href="http://everet.org/2013/01/http-status-206-partial-content.html"/>
    <updated>2013-01-06T10:31:00+08:00</updated>
    <id>http://everet.org/2013/01/http-status-206-partial-content</id>
    <content type="html"><![CDATA[<p>俺在把博客放在Github后，除了发现Github的Web Server将Cache-Control设置为max-age=86400外，还发现一个有趣的地方。Chrome在对于MP3文件的访问，Github返回的都是<code>206 Partial Content</code>，后来发现，原来Chrome在请求MP3的时候，会在请求头带上<code>Range: bytes=0-</code>。</p>

<p>对于2xx的返回码，都是成功的，不过常见的基本都是200，206到时挺少见滴，于是俺决定看看206究竟有什么特别的地方。</p>

<p>rfc2616日：对于206的定义是请求<strong>必须</strong>包含<code>Range</code>头来标示我们想要的范围，于是这也就说明Chrome访问MP3的时候因为加了<code>Range</code>头，于是被返回了206。</p>

<p>我们来看一下下面的例子：用curl请求<a href="http://everet.org/2013/01/chrome-edit-with-emacs.html">http://everet.org/2013/01/chrome-edit-with-emacs.html</a>，返回<code>200 OK</code>，其中<code>Content-Length: 15845</code>。</p>

<p><code>bash
$ curl --head http://everet.org/2013/01/chrome-edit-with-emacs.html
HTTP/1.1 200 OK
Server: GitHub.com
Date: Sun, 06 Jan 2013 02:47:09 GMT
Content-Type: text/html
Content-Length: 15845
Last-Modified: Sat, 05 Jan 2013 10:30:34 GMT
Connection: keep-alive
Expires: Mon, 07 Jan 2013 02:47:09 GMT
Cache-Control: max-age=86400
Accept-Ranges: bytes
</code></p>

<p>那根据rfc2616的说法，是不是加上<code>Range</code>后，Web Server就会返回<code>206 Partial Content</code>了呢？我们来通过telnet试一试：</p>

<!-- more -->

<p>``` bash
$ telnet everet.org www
Trying 204.232.175.78…
Connected to everet.org.
Escape character is ‘^]’.
GET /2013/01/chrome-edit-with-emacs.html HTTP/1.1
Host: everet.org
Range: bytes=0-100</p>

<p>HTTP/1.1 206 Partial Content
Server: GitHub.com
Date: Sun, 06 Jan 2013 03:20:05 GMT
Content-Type: text/html
Content-Length: 101
Last-Modified: Sat, 05 Jan 2013 10:30:34 GMT
Connection: keep-alive
Expires: Mon, 07 Jan 2013 03:20:05 GMT
Cache-Control: max-age=86400
Content-Range: bytes 0-100/15845</p>

<p>&lt;!DOCTYPE html&gt;
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
&lt;!–[if lt IE 9]&gt;&lt;html cl
```</p>

<p>可以看到，服务器返回了100个字节的字符。为了方便测试，我们使用curl来尝试分块下载。</p>

<p><code>bash
$ curl http://everet.org/2013/01/chrome-edit-with-emacs.html -o a.html
$ curl --header "Range: bytes=0-10000" http://everet.org/2013/01/chrome-edit-with-emacs.html -o p1
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
  100 10001  100 10001    0     0  13227      0 --:--:-- --:--:-- --:--:-- 20451
$ curl --header "Range: bytes=10001-" http://everet.org/2013/01/chrome-edit-with-emacs.html -o p2
  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current
                                 Dload  Upload   Total   Spent    Left  Speed
  100  5844  100  5844    0     0   7778      0 --:--:-- --:--:-- --:--:-- 12175
$ cat p1 p2 &gt; b.html
$ diff a.html b.html 
</code></p>

<p>我们将原始页面下载回命名为a.html。然后通过增加<code>Range</code>这个header来下载<code>0-10000</code>为p1，以及<code>10001-</code>下载剩余部分为p2。然后合并p1、p2为b.html。通过<code>diff a.html b.html</code>发现a.html和b.html内容完全一样。</p>

<p>嗯，正如我们所想的那样，加上<code>Range</code>后可以下载指定部分的内容，相应地服务器会返回<code>206 Partial Content</code>。</p>

<h2 id="range">Range范围的例子</h2>
<p>这个例子是rfc2616里面的，首先假定entity-body长度为10000。</p>

<ul>
  <li>获取前500个字节 (byte offsets 0-499, inclusive):  bytes=0-499</li>
  <li>获取第二个500字节 (byte offsets 500-999, inclusive): bytes=500-999</li>
  <li>获取最后500字节 (byte offsets 9500-9999, inclusive): bytes=-500</li>
  <li>获取最后500字节 bytes=9500-</li>
  <li>第一个和最后一个字节 (bytes 0 and 9999):  bytes=0-0,-1</li>
  <li>Several legal but not canonical specifications of the second 500
bytes (byte offsets 500-999, inclusive):
 bytes=500-600,601-999
 bytes=500-700,601-999</li>
</ul>

<h2 id="section">总结</h2>
<p>我们可以通过<code>Range</code>和<code>206 Partial Content</code>来分块获取一个大文件。在offset有效的时候，Web Server会返回206，否则会返回<code>416 Requested Range Not Satisfiable</code>。</p>

<h2 id="section-1">扩展阅读</h2>
<ul>
  <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html">Status Code Definitions</a></li>
  <li><a href="http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.35">Range</a></li>
</ul>
]]></content>
  </entry>
  
</feed>
